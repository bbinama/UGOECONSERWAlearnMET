#' Processing and selecting predictors to fit the model
#'
#' @param split A \code{split} object, corresponding to one element of the total
#'   `cv_object` generated by one of the functions [predict_cv0()], 
#'   [predict_cv1()], or [predict_cv2()], and containing:
#'   \describe{
#'     \item{training}{\code{data.frame} Training dataset}
#'     \item{test}{\code{data.frame} Test dataset}
#'   }
#' @param geno_data \code{data.frame} A `geno` element of an object of class 
#'   `METData`.
#'   
#' @param geno_information A \code{character} indicating how the genotypic
#'   information should be processed to be used in predictions. Options are
#'   `SNPs`, `PCs` or `PCs_G`.
#'   
#' @param use_selected_markers A \code{logical} indicating whether to use a
#'   subset of markers obtained from a previous step (see function 
#'   [select_markers()]).
#'   
#' @param SNPs A \code{data.frame} with the genotype matrix for the selected
#'   markers of the [select_markers()] step. 
#'   
#' @param list_env_predictors A \code{character} vector containing the names
#'   of the environmental predictors which should be used in predictions. 
#'   
#' @param include_env_predictors A \code{logical} indicating whether 
#'   environmental covariates characterizing each environment should be used in
#'   predictions.
#'   
#' @param lat_lon_included \code{logical} indicates if longitude and latitude
#'   data should be used as numeric predictors. 
#'   
#' @param year_included \code{logical} indicates if year factor should be used
#'   as predictor variable. 
#' 
#' @return a \code{split_processed} list object containing:
#' \describe{
#'   \item{training}{\code{data.frame} Training set}
#'   \item{test}{\code{data.frame} Test set}
#'   \item{rec}{\code{recipe} object with the different steps to implement
#'    as processing steps on the training dataset. Same transformations applied
#'    on the test set.}
#'     }
#' @author Cathy C. Jubin \email{cathy.jubin@@uni-goettingen.de}
#' @export
#'
#'


processing_train_test_split <-
  function(split,
           geno_data,
           geno_information,
           use_selected_markers,
           SNPs,
           list_env_predictors,
           include_env_predictors,
           lat_lon_included,
           year_included) {
    
    ## GENOTYPIC DATA ## 
    
    # Use of genotypic data: specified via parameter geno_information #
    
    if (geno_information== 'PCs') {
      # Processing of PCs: apply transformations calculated on the training set
      # on test set --> dimensionality reduction method
      
      cat('Processing: PCA transformation on the Training Set\n')
      pca_geno = apply_pca(split = split,geno=geno_data)
      
      # Merge in same data pheno and geno data for each train & test split
      
      training <-
        merge(split[[1]], pca_geno, by = 'geno_ID', all.x = T)
      
      test <-
        merge(split[[2]], pca_geno, by = 'geno_ID', all.x = T)
      
      cat('Processing: PCA transformation done\n')
      
    }
    
   
    # Add SNP covariates if they should be used
    
    if (use_selected_markers & geno_information != 'SNPs') {
      
      training <- merge(training, SNPs, by = 'geno_ID', all.x = T)
      
      test <- merge(test, SNPs, by = 'geno_ID', all.x = T)
      
    }
    
    
    ## ENVIRONMENTAL DATA ## 
    # Add the environmental data
    
    # Two different cases:
    # Case 1: each environmental covariate is unique for a complete environment
    # (e.g. ECs are not computed individually for each variety within an 
    # environment).
    
    if (include_env_predictors & !is.null(list_env_predictors) & !METData$unique_EC_by_geno) {
      
      
      
      training <-
        merge(training,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = 'IDenv',
              all.x = T)
      test <-
        merge(test,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = 'IDenv',
              all.x = T)
      
    }
    
    # Case 2: each environmental covariate is computed specifically for an
    # environment AND for a genotype (e.g. ECs are computed individually 
    # for each variety within an environment).
    
    if (include_env_predictors & !is.null(list_env_predictors) & METData$unique_EC_by_geno) {
      
      
      
      training <-
        merge(training,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = c('IDenv','geno_ID'),
              all.x = T)
      test <-
        merge(test,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = c('IDenv','geno_ID'),
              all.x = T)
      
    }
    
    if (lat_lon_included & year_included & length(unique(as.character(training$year)))>1) {
      # Add longitude/latitude data for each train & test split
      
      training <-
        merge(training,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      test <-
        merge(test,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)

      
      
      # Create recipe to define the processing of the training & test set.
      
      rec <- recipe(~ . ,
                    data = training) %>%
        update_role(trait, new_role = 'outcome') %>%
        update_role(IDenv, new_role = "id variable") %>%
        step_rm(location) %>%
        step_rm(geno_ID) %>%
        update_role(-trait,-IDenv, new_role = 'predictor') %>%
        step_dummy(year, preserve = F, one_hot = TRUE) %>%
        step_nzv(all_predictors(),-starts_with('PC'))%>%
        step_normalize(all_numeric(),-all_outcomes(), -starts_with('PC')) 
        
      
     
      
      
    }
    else if (!lat_lon_included &
             year_included & length(unique(as.character(training$year)))>1) {
      
      
      # Create recipe to define the processing of the training & test set.
      
      rec <- recipe(~ . ,
                    data = training) %>%
        update_role(trait, new_role = 'outcome') %>%
        update_role(IDenv, new_role = "id variable") %>%
        step_rm(location) %>%
        step_rm(geno_ID) %>%
        update_role(-trait,-IDenv, new_role = 'predictor') %>%
        step_dummy(year, preserve = F, one_hot = TRUE) %>%
        step_nzv(all_predictors(),-starts_with('PC')) %>%
        step_normalize(all_numeric(),-all_outcomes(), -starts_with('PC')) 
      
     
      
      
    }
    
    else if ((lat_lon_included &
             !year_included) | (lat_lon_included &
                                length(unique(as.character(training$year)))<2) ) {
      # Add longitude/latitude data for each train & test split
      
      training <-
        merge(training,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      test <-
        merge(test,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      
      
      # Create recipe to define the processing of the training & test set.
      
      rec <- recipe(~ . ,
                    data = training) %>%
        update_role(trait, new_role = 'outcome') %>%
        update_role(IDenv, new_role = "id variable") %>%
        step_rm(location) %>%
        step_rm(geno_ID) %>%
        step_rm(year) %>%
        update_role(-trait,-IDenv, new_role = 'predictor') %>%
        step_nzv(all_predictors(),-starts_with('PC')) %>%
        step_normalize(all_numeric(),-all_outcomes(), -starts_with('PC'))
      
     
      
      
    }
    else{
      
      # Create recipe to define the processing of the training & test set.
      
      rec <- recipe(~ . ,
                    data = training) %>%
        update_role(trait, new_role = 'outcome') %>%
        update_role(IDenv, new_role = "id variable") %>%
        step_rm(location) %>%
        step_rm(geno_ID) %>%
        step_rm(year) %>%
        update_role(-trait,-IDenv, new_role = 'predictor') %>%
        step_nzv(all_predictors(),-starts_with('PC')) %>%
        step_normalize(all_numeric(),-all_outcomes(), -starts_with('PC'))
      
     
      
      
    }
    cat('Incorporating selected predictors & Data processing for one train/test split of the CV scheme: Done!\n')
    
    split_processed <- list(
      "training" = training, 
      "test" = test, 
      "rec" = rec)
    class(split_processed) <- 'split_processed'
    return(split_processed)
    
  }
