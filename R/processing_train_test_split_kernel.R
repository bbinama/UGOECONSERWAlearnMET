#' Processing and selecting predictors to fit the model
#'
#' @param split An object of class \code{split}, corresponding to one element of
#'   the total `cv_object` generated by one of the functions [predict_cv0()],
#'   [predict_cv1()], or [predict_cv2()], and containing the following items:
#' * **training**: \code{data.frame} Training dataset.
#' * **test**: \code{data.frame} Test dataset.
#'   
#'
#' @param geno_data \code{data.frame} A `geno` element of an object of class
#'   `METData`.
#'
#' @param geno_information A \code{character} indicating how the genotypic
#'   information should be processed to be used in predictions. Options are
#'   `SNPs`, `PCs` or `PCs_G`.
#'
#' @param use_selected_markers A \code{logical} indicating whether to use a
#'   subset of markers obtained from a previous step (see function
#'   [select_markers()]).
#'
#' @param SNPs A \code{data.frame} with the genotype matrix for the selected
#'   markers of the [select_markers()] step.
#'
#' @param list_env_predictors A \code{character} vector containing the names
#'   of the environmental predictors which should be used in predictions.
#'
#' @param include_env_predictors A \code{logical} indicating whether
#'   environmental covariates characterizing each environment should be used in
#'   predictions.
#'
#' @param lat_lon_included \code{logical} indicates if longitude and latitude
#'   data should be used as numeric predictors. Default is `FALSE`.
#'
#' @param year_included \code{logical} indicates if year factor should be used
#'   as predictor variable. Default is `FALSE`.
#'
#' @return an object of class \code{split_processed} with the following items:
#' * **training**: \code{data.frame} Training set.
#' * **test**:\code{data.frame} Test set.
#' * **rec_G**:\code{recipe} object with the different steps to process
#'    molecular marker dataset from the training set. Same transformations
#'    applied on the test set.
#' * **rec_E**:\code{recipe} object with the different steps to process
#'    environmental data from the training set. Same transformations applied on
#'    the test set.
#' * **rec_GE**:\code{recipe} object with the different steps to process
#'    the GxE dataset from the training set. Same transformations applied on
#'    the test set.
#'    
#' @author Cathy C. Jubin \email{cathy.jubin@@uni-goettingen.de}
#' @export
#'
#'


processing_train_test_split_kernel <-
  function(split,
           geno_data,
           geno_information,
           use_selected_markers,
           SNPs,
           list_env_predictors,
           include_env_predictors,
           lat_lon_included = F,
           year_included = F,
           ...) {
    geno_data$geno_ID = row.names(geno_data)
    
    ## SNPs DATA ## 
    # Add the genotype data
    
    # Merge in same data.frame pheno and geno data for each train & test split
    
    training <-
      merge(split[[1]], geno_data, by = 'geno_ID', all.x = T)
    
    test <-
      merge(split[[2]], geno_data, by = 'geno_ID', all.x = T)
    
    ## ENVIRONMENTAL DATA ## 
    # Add the environmental data
    
    # Two different cases:
    # Case 1: each environmental covariate is unique for a complete environment
    # (e.g. ECs are not computed individually for each variety within an 
    # environment).
    
    if (include_env_predictors & !is.null(list_env_predictors) & !METData$unique_EC_by_geno) {
      
      
      
      training <-
        merge(training,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = 'IDenv',
              all.x = T)
      test <-
        merge(test,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = 'IDenv',
              all.x = T)
      
    }
    
    # Case 2: each environmental covariate is computed specifically for an
    # environment AND for a genotype (e.g. ECs are computed individually 
    # for each variety within an environment).
    
    if (include_env_predictors & !is.null(list_env_predictors) & METData$unique_EC_by_geno) {
      
      
      
      training <-
        merge(training,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = c('IDenv','geno_ID'),
              all.x = T)
      test <-
        merge(test,
              METData$env_data[, c('IDenv', list_env_predictors)],
              by = c('IDenv','geno_ID'),
              all.x = T)
      
    }
    
    
    
    ## ENVIRONMENTAL-BASED KERNEL ##
    
    if (lat_lon_included &
        year_included &
        length(unique(as.character(training$year))) > 1) {
      # Add longitude/latitude data for each train & test split
      
      training <-
        merge(training,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      test <-
        merge(test,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      
      
      
      # Create recipe to define the processing of the training & test set.
      
      rec_E <- recipes::recipe( ~ . ,
                                data = training) %>%
        recipes::update_role(tidyselect::all_of(trait), new_role = 'outcome') %>%
        recipes::update_role(IDenv, new_role = "id variable") %>%
        recipes::step_rm(all_of(colnames(geno_data))) %>%
        recipes::step_rm(location) %>%
        recipes::step_rm(colnames(geno_data)) %>%
        recipes::update_role(-tidyselect::all_of(trait), -IDenv, new_role = 'predictor') %>%
        recipes::step_dummy(year, preserve = F, one_hot = TRUE) %>%
        recipes::step_nzv(recipes::all_predictors()) %>%
        recipes::step_normalize(recipes::all_numeric(), -recipes::all_outcomes())
      
      
      
      
      
    } else if (!lat_lon_included &
               year_included &
               length(unique(as.character(training$year))) > 1) {
      # Create recipe to define the processing of the training & test set.
      
      rec_E <- recipes::recipe( ~ . ,
                                data = training) %>%
        recipes::update_role(tidyselect::all_of(trait), new_role = 'outcome') %>%
        recipes::update_role(IDenv, new_role = "id variable") %>%
        recipes::step_rm(all_of(colnames(geno_data))) %>%
        recipes::step_rm(location) %>%
        recipes::update_role(-tidyselect::all_of(trait), -IDenv, new_role = 'predictor') %>%
        recipes::step_dummy(year, preserve = F, one_hot = TRUE) %>%
        recipes::step_nzv(recipes::all_predictors()) %>%
        recipes::step_normalize(recipes::all_numeric(), -recipes::all_outcomes())
      
      
      
      
    } else if ((lat_lon_included &
                !year_included) | (lat_lon_included &
                                   length(unique(as.character(training$year))) <
                                   2)) {
      # Add longitude/latitude data for each train & test split
      
      training <-
        merge(training,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      test <-
        merge(test,
              METData$info_environments[, c('IDenv', 'longitude', 'latitude')],
              by = 'IDenv',
              all.x = T)
      
      
      # Create recipe to define the processing of the training & test set.
      
      rec_E <- recipes::recipe( ~ . ,
                                data = training) %>%
        recipes::update_role(tidyselect::all_of(trait), new_role = 'outcome') %>%
        recipes::update_role(IDenv, new_role = "id variable") %>%
        recipes::step_rm(all_of(colnames(geno_data))) %>%
        recipes::step_rm(location) %>%
        recipes::step_rm(year) %>%
        recipes::update_role(-tidyselect::all_of(trait), -IDenv, new_role = 'predictor') %>%
        recipes::step_nzv(recipes::all_predictors()) %>%
        recipes::step_normalize(recipes::all_numeric(), -recipes::all_outcomes())
      
      
      
      
    } else{
      # Create recipe to define the processing of the training & test set.
      
      rec_E <- recipes::recipe( ~ . ,
                                data = training) %>%
        recipes::update_role(tidyselect::all_of(trait), new_role = 'outcome') %>%
        recipes::update_role(IDenv, new_role = "id variable") %>%
        recipes::step_rm(all_of(colnames(geno_data))) %>%
        recipes::step_rm(location) %>%
        recipes::step_rm(year) %>%
        recipes::update_role(-tidyselect::all_of(trait), -IDenv, new_role = 'predictor') %>%
        recipes::step_nzv(recipes::all_predictors()) %>%
        recipes::step_normalize(recipes::all_numeric(), -recipes::all_outcomes())
      
      
      
      
    }
    
    cat('Processing: recipe for the environmental-based kernel created!\n')
    
    ## GENOMIC BASED KERNEL ##
    
    rec_G <- recipes::recipe( ~ . ,
                              data = training) %>%
      recipes::update_role(tidyselect::all_of(trait), new_role = 'outcome') %>%
      recipes::update_role(IDenv, new_role = "id variable") %>%
      recipes::update_role(geno_ID, new_role = "id variable") %>%
      recipes::step_rm(location) %>%
      recipes::step_rm(year) %>%
      recipes::step_rm(all_of(list_env_predictors)) %>%
      recipes::update_role(-tidyselect::all_of(trait), -IDenv, -geno_ID, new_role = 'predictor') %>%
      recipes::step_nzv(recipes::all_predictors()) %>%
      #recipes::step_corr(recipes::all_predictors(),
      #                   skip = TRUE,
      #                   threshold = 0.95) %>%
      recipes::step_normalize(recipes::all_numeric(), -recipes::all_outcomes())
    
    
    
    cat('Processing: recipe for the genomic-based kernel created!\n')
    
    ## KERNEL WITH INTERACTIONS BETWEEN SNPS AND ENVIRONMENTAL COVARIATES ##
    
    if (use_selected_markers) {
      rec_GE <- recipes::recipe( ~ . ,
                                 data = training) %>%
        recipes::update_role(tidyselect::all_of(trait), new_role = 'outcome') %>%
        recipes::update_role(IDenv, new_role = "id variable") %>%
        recipes::step_interact(
          terms = ~ all_of(colnames(SNPs)[colnames(SNPs) %notin% 'geno_ID']):all_of(list_env_predictors),
          role = 'predictor'
        )  %>%
        recipes::step_rm(all_of(colnames(geno_data))) %>%
        recipes::step_rm(all_of(list_env_predictors)) %>%
        recipes::step_rm(location) %>%
        recipes::step_rm(year) %>%
        recipes::update_role(-all_of(trait), -IDenv, new_role = 'predictor') %>%
        recipes::step_nzv(recipes::all_predictors()) %>%
        recipes::step_normalize(recipes::all_numeric(), -recipes::all_outcomes())
      
    }
    cat(
      paste(
        'Processing: recipe for the kernel with interactions between',
        'genomic and environmental predictors created!\n'
      )
    )
    split_processed <- list(
      'training' = training,
      'test' = test,
      'rec_G' = rec_G,
      'rec_E' = rec_E,
      'rec_GE' = rec_GE
    )
    class(split) <- 'split_processed'
    return(split_processed)
    
    
    
    
    
  }
